##GUI Basics and Windowing Systems##
*Using X Windows as a case study*

---
Evolution of GUI Programming

- On early computers, everything was "rolled by hand"
	- Re-inventing the wheel with every iteration
- Interaction was very, very limited
- No graphical input or output
	- Ivan Sutherland Sketchpad system
- No standards for interaction
- Leading up to the 1980's, researcher and industry began to develop GUI architectures and systems to simplify programming
	- The Macintosh was the first successful commercial GUI, but there were a large number of competing systems introduced in the 80s and 90s!

---
Evolution of GUIs

- Xerox Star (1981)
	- Developed at Xerox PARC
	- Not commercially successful
- Apple Macintosh (1984)
	- Inspired by Xerox PARC
	- Commercial hit!
- Amiga Workbench (1985)
	- Limited success
- Microsoft Windows 1.0 (1985)
	- Limited success, led to Windows 3.0

---
X Windows (X11) System

X Windows

- Developed in 1984 (based on MIT Athena project)
- emerged as standard windowing system for Unix
- Free and cross-platform (OS, processor agnostic)
- one of the most successful free-software projects, ever
- Base windowing system, separate from operating system.
	- not a window manager (more on that later)
	- does not specify the style of user interface
- What does it do?
	- a protocol to create windows, handle input, draw graphics
	- a standard for low-level graphical output and user input

---
X Windows Design Criteria (~1986)

1. implementable on a variety of displays
2. applications must be device independent
3. must be network transparent
4. support multiple, concurrent application displays
5. support many different applications
6. support output to overlapping windows (... even when partially obscured)
7. support a hierarchy of resizable windows (... an application can use many windows at once)
8. high-performance, high-quality text, 2-D graphics, imaging
9. system should be extensible

---
Displays, Screens, Windows

- In X, a display may have multiple screens
- A display may have multiple windows
- a window may cross multiple screens

---
X Client-Server Architecture

- Separate user interface and application:
	- the X Client handles all application logic
	- the X Server handles all display output and user input
- a server handles requests from multiple clients, processes data as requested, and returns the results to the clients
- X inverts conventional www server/client relationship
	- in www, web browser is the "client", web site is the "server"

---
Why Client-Server?

- goal was flexibility and economy
- many clients (perhaps multiple machines) running applications
- one display used to monitor the apps

---
X Windows as MVC Architecture

---
Structure of a Typical X Program

1. perform client initialization
2. connect to the X server
3. perform X related initialization
4. event loop:
	- get next event from the X server
	- handle the event:
		- if the event was a quit message, exit the loop
		- do any client-initiated work
	- send drawing requests to the X server
5. close down the connection to the x server
6. perform client cleanup

---
Xlib (X Windows Library)

- library to wrap low level X Window protocol
	- to avoid implementing message passing for every new program
- Xlib is not a window manager
- Xlib does not specify style of user interface or provide "widgets"
- uses buffered input and output queues
	- need to flush them: XSync, XFlush
- Xlib functions:
	- connection operations: e.g. XOpenDisplay, XCloseDisplay, ...
	- connection operation requests:  e.g. XCreateWindow, XCreateGC,...
	- connection information requests: e.g. XGetWindowProperty, ...
	- local event queue operations: e.g. XNextEvent, XPeekEvent, ...
	- local data operations: e.g. XLookupKeysym, XParseGeometry, XSetRegion, XCreateImage, XSaveContext, ...
- Xlib data types:
	- e.g. Display, Window, GC, XSizeHints, XWhitePixel, etc.

---
Display a Window (openwindow.min.cpp)

---

Opening a Window in Java

---
Recap: X Windows Design

- much of the XWindows architecture was influenced by its time period
	- larger server machines and low-cost client displays because computation was expensive
- as computation git cheaper, certain aspects of program behaviour could be assumed:
	- software runs on the client computer
	- OS handles display rendering and has device drivers to coordinate with specific hardware
- over time, in a multi-OS world, even this restriction became a burden:
	- services could be abstracted even farther from the underlying architectures, and programs could run on virtual machines (e.g. JVM, .NET VM, etc.)
	- write once for a generic 'virtual' architecture, tun the program on the virtual machine
	- any platform for which the 'VM' is implemented could execute the same program

##Intermission##
*How to run X11 sample code.*

---
Windows: C++ Examples

- On Windows, you can use Virtual Box and Linux for Xlib examples	- Install virtual box, download Ubuntu (or another linux distro) as an ISO
	- Open Virtual Box and create an Ubuntu Linux VM
	- Select, but do not start, and update IDE secondary master to point to Linux ISO
	- Start VM and install should proceed
	- Then
		- Install g++ with
			- sudo apt-get install g++
		- Install X11 dev options with
			- sudo apt-get install libx11-dev


