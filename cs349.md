##CS 349##

Jeff Avery

- Assignments: 40%	- 10%, 10%, 10%, 10%- Midterm: 20%	- Thurs June 9 @ 7:00 PM – 8:50 PM (location TBD)- Final: 40%	- Scheduled by the Registrar’s Office

To pass the course, you must pass the weighted exam average and the weighted assignment average

---
Definition: User Interface

A user interface is the place where a person expresses intention to an artifact, and the artifact presents feedback to the person.

---
Interactive System Architecture

---
Model-View-Controller (MVC)

---
Graphical Temperature Control

---
Speech Temperature Control

---
Interface vs. Interaction

- What is the difference between an interface and interaction?	- Interface refers to the external presentation to the user		- Controls (what you can manipulate to communicate intent)
		- Visual, physical, auditory presentation (what the program uses to communicate its response)- Interaction is used to connote behavior: The actions the user must invoke to perform a task and the corresponding responses	- Interaction is action and dialog
	- Unfolds over time

---
Interaction Design

- Challenging because of variability in users and tasks	- Varying levels of expertise among users
	- Often a range of tasks will performed with the same tool (i.e. tools can be generic) – can you anticipate all uses and scenarios?- No one “right way” to design an interface; interfaces can always be improved.- Pushing technology “forward” requires us to rethink interaction. - Emergence of UX as a discipline

---
Why Study Interaction? Empowering People

- Well designed interfaces empower people to do things they couldn’t otherwise do	- Desktop publishing, grassroots journalism (blogs), movie production, music production, image editing, assistive technologies...- Interaction is the key to enabling new technologies	- Multi-touch and gestures on smartphones
	- Voice interfaces for cars, watches- A well designed tool can literally change the world	- The web browser, Linux, original Napster, the spreadsheet, email, instant messaging...

##GUI Basics and Windowing Systems##
*Using X Windows as a case study*

---
Evolution of GUI Programming

- On early computers, everything was "rolled by hand"
	- Re-inventing the wheel with every iteration
- Interaction was very, very limited
- No graphical input or output
	- Ivan Sutherland Sketchpad system
- No standards for interaction
- Leading up to the 1980's, researcher and industry began to develop GUI architectures and systems to simplify programming
	- The Macintosh was the first successful commercial GUI, but there were a large number of competing systems introduced in the 80s and 90s!

---
Evolution of GUIs

- Xerox Star (1981)
	- Developed at Xerox PARC
	- Not commercially successful
- Apple Macintosh (1984)
	- Inspired by Xerox PARC
	- Commercial hit!
- Amiga Workbench (1985)
	- Limited success
- Microsoft Windows 1.0 (1985)
	- Limited success, led to Windows 3.0

---
X Windows (X11) System

X Windows

- Developed in 1984 (based on MIT Athena project)
- emerged as standard windowing system for Unix
- Free and cross-platform (OS, processor agnostic)
- one of the most successful free-software projects, ever
- Base windowing system, separate from operating system.
	- not a window manager (more on that later)
	- does not specify the style of user interface
- What does it do?
	- a protocol to create windows, handle input, draw graphics
	- a standard for low-level graphical output and user input

---
X Windows Design Criteria (~1986)

1. implementable on a variety of displays
2. applications must be device independent
3. must be network transparent
4. support multiple, concurrent application displays
5. support many different applications
6. support output to overlapping windows (... even when partially obscured)
7. support a hierarchy of resizable windows (... an application can use many windows at once)
8. high-performance, high-quality text, 2-D graphics, imaging
9. system should be extensible

---
Displays, Screens, Windows

- In X, a display may have multiple screens
- A display may have multiple windows
- a window may cross multiple screens

---
X Client-Server Architecture

- Separate user interface and application:
	- the X Client handles all application logic
	- the X Server handles all display output and user input
- a server handles requests from multiple clients, processes data as requested, and returns the results to the clients
- X inverts conventional www server/client relationship
	- in www, web browser is the "client", web site is the "server"

---
Why Client-Server?

- goal was flexibility and economy
- many clients (perhaps multiple machines) running applications
- one display used to monitor the apps

---
X Windows as MVC Architecture

---
Structure of a Typical X Program

1. perform client initialization
2. connect to the X server
3. perform X related initialization
4. event loop:
	- get next event from the X server
	- handle the event:
		- if the event was a quit message, exit the loop
		- do any client-initiated work
	- send drawing requests to the X server
5. close down the connection to the x server
6. perform client cleanup

---
Xlib (X Windows Library)

- library to wrap low level X Window protocol
	- to avoid implementing message passing for every new program
- Xlib is not a window manager
- Xlib does not specify style of user interface or provide "widgets"
- uses buffered input and output queues
	- need to flush them: XSync, XFlush
- Xlib functions:
	- connection operations: e.g. XOpenDisplay, XCloseDisplay, ...
	- connection operation requests:  e.g. XCreateWindow, XCreateGC,...
	- connection information requests: e.g. XGetWindowProperty, ...
	- local event queue operations: e.g. XNextEvent, XPeekEvent, ...
	- local data operations: e.g. XLookupKeysym, XParseGeometry, XSetRegion, XCreateImage, XSaveContext, ...
- Xlib data types:
	- e.g. Display, Window, GC, XSizeHints, XWhitePixel, etc.

---
Display a Window (openwindow.min.cpp)

---

Opening a Window in Java

---
Recap: X Windows Design

- much of the XWindows architecture was influenced by its time period
	- larger server machines and low-cost client displays because computation was expensive
- as computation git cheaper, certain aspects of program behaviour could be assumed:
	- software runs on the client computer
	- OS handles display rendering and has device drivers to coordinate with specific hardware
- over time, in a multi-OS world, even this restriction became a burden:
	- services could be abstracted even farther from the underlying architectures, and programs could run on virtual machines (e.g. JVM, .NET VM, etc.)
	- write once for a generic 'virtual' architecture, tun the program on the virtual machine
	- any platform for which the 'VM' is implemented could execute the same program

##Intermission##
*How to run X11 sample code.*

---
Windows: C++ Examples

- On Windows, you can use Virtual Box and Linux for Xlib examples	- Install virtual box, download Ubuntu (or another linux distro) as an ISO
	- Open Virtual Box and create an Ubuntu Linux VM
	- Select, but do not start, and update IDE secondary master to point to Linux ISO
	- Start VM and install should proceed
	- Then
		- Install g++ with
			- sudo apt-get install g++
		- Install X11 dev options with
			- sudo apt-get install libx11-dev

---
Windows: VM Setup

- You may wish to map a local directory onto a subdirectory in my home directory as follows:	- Install Guest Additions from the Devices menu of the VM
	- On your local machine create a folder
	- From Machine > Settings > Shared Folders click the add icon and create a new directory pointing to that folder.
	- Check the auto-mount and make permanent options
	- On your host OS, make sure that the folder permissions make it accessible
	- Create a symbolic link to /media/<shared folder> to a subdirectory of your home directory.

---
Mac & Linux: C++ Examples

- On Mac OS X, this is much simpler:	- Install a version of the X Window System (Xquartz) from http://www.xquartz.org- On Linux, this is trivial:	- You’re already running X. Just compile your code.- Samples posted on the course website, along with a makefile (pay attention to the include for the X11 libs!)

##Windowing Systems##
*Windowing Systems, Basic Drawing, Events (Event Loop, Animation, Double-Buffering)*

---
Before Windowing Systems

---
X Windows Design Criteria (~1986)

- implementable on a variety of displays
- applications must be device independent
- must be network transparent
- support multiple, concurrent application displays
- support many different application and management interfaces
- support output to overlapping windows (... even when partially obscured)
- support a hierarchy of resizable windows (... an application can use many windows at once)
- high-performance, high-quality text, 2-D graphics, imaging
- system should be extensible

---
How to support multiple windows?

---
Base Window System (BWS)

- Lowest level abstraction for windowing system
- Routines for creating, destroying, managing windows- Routes input to correct window
- Ensures only one application changing frame buffer (video memory) at a time
	- one reason why single-threaded / non-thread-safe GUI architectures are popular
- Creates canvas abstraction for applications
	- Applications shielded from details of frame buffer, visibility of window, other application windows- Each window has its own coordinate system	- BWS transforms between coordinate systems
	- Each window does not need to worry where it is on screen, always assumes its top-left is (0,0)- Provides basic graphics routines for drawing

---
Window Manager

- Provides conceptually different functionality	- Layered on top of Base Window System
	- Provides interactive components for windows (menus, close box, resize capabilities)
	- Creates the “look and feel” of each window
- Application Window vs. Application “Canvas”	- the window manager owns the window (including its controls)
	- the application owns the canvas

---
BWS vs. Window Managers

- Separation of Base Window System (BWS) from Window Manager (WM)
	- Enables many alternative “look and feels” for the windowing system (e.g., KDE, GNOME...)
	- One of the keys to its lasting power: can innovate by changing the WM layer
	- Resiliency, since BWS and WM are separate processes
- OSX, Windows combine “BWS” and Window Manager- Trade-offs in approaches?	- Look and feel...
	- Window management possibilities... 
	- Input possibilities...- Conceptually, on both platforms, there is a separation of canvas (assigned to application) and window decoration/OS overlay handled by window manager	- Lines do blur when combined, however	- e.g. Windows fast access menu-bar in the window frame

---
Motif (Stacking)

---
DWM (tiling)

---
Win (compositing)

##Basic GUI Drawing##

Local Coordinates

- Any modern OS manages multiple windows	- where the window is located, whether it is covered by another window, etc...
	- enables drawing using local coordinate system for window

--
Drawing Models

Three different conceptual drawing models:

- Pixel
	- SetPixel(s,y,colour)
	- DrawImage(x,y,w,h,img)
- Stroke
	- DrawLine(x1, y1, x2, y2, colour)
	- DrawRect(x, y, w, h, colour)
- Region
	- DrawLine(x1, y1, x2, y2, color, thick)
	- DrawRect(x, y, w, h, colour, thick, fill)
	- DrawText(“A”, x, y, colour)

--
Drawing Options

- Lots of options for drawing
	- e.g. drawLine(x1,y1,x2,y2)
		- what colour?
		- how thick?
		- dashed or solid?
		- where are the end points?
		- how should the ends overlap?
	- Observation: most choices are the same for multiple calls to drawLine
- How to communicate all the options?
	- lots of parameters?
	- more functions that are more specific?
	- something else?

--
Graphics Context

- Gather all drawing options into a single structure and pass it to the drawing routines
	- In X, the GC structure- All graphics environments use variation on this approach
	- Java/C#: Graphics Object
	- OpenGL: Attribute State- In X, the graphics context is stored on X server
	- Switch between multiple saved contexts to reduce network traffic
	- But limited memory on server
	- There is a default context
	- The context is global to the application: need a policy- With modern applications, we don’t separate client application and XServer UI routines, but assumption of repeated attributes still applies	- Drawing is interpreted in context of graphics object, attribute state ...

--
Simplifying Drawing With Clipping

- what are some other problems that might arise when trying to draw on a computer display?
- Clipping and the Painter's Algorithm

--
Code Demo: clipping.cpp

	if (!is_clipping)
		XSetClipMask(display, gc, None);
	else
		XSetClipRectangles(
			display, gc, 0, 0, &clip_rect, 1, Unsorted);

- XSetClipMask
- XSetClipRectangles

--
Painter's Algorithm

- The basic graphics primitives are primitive.
- To draw more complex shapes:
	- Draw back-to-front, layering the image
	- Called “Painter’s Algorithm”

--
Painters Algorithm Analogy

--
Implementing the Painters Algorithm

- Keep an ordered list of “displayables”
	- Order: Back – to – Front.- Each displayable knows how to display itself on the screen
	- Base class with a “paint” method
	- Derived classes for different kinds of displayables: text, game sprites, etc.- Repaint
	- Clear window
	- Repaint everything in the display list

--
Displayable Base Class

	/*
	  * An abstract class representing displayable * things.
	*/
	class Displayable {
		public:
			virtual void paint(XInfo &xinfo) = 0;
	};

--
Displayable Text

	/* Display some text */
	class Text : public Displayable 
	{ public:
		virtual void paint(XInfo &xinfo)
		{ XDrawImageString( xinfo.display,
			xinfo.window, xinfo.gc, this->x, 
			this->y, this->s.c_str(), 
			this->s.length() );
		}		
		// constructor
		Text(int x, int y, string s):x(x), y(y), s(s) {}	private:		int x; int y; 
		string s;	};

--
Displayable Polyline

	/* A Displayable polyline */
	class Polyline : public Displayable {		public:		virtual void paint(XInfo& xinfo) {			XDrawLines(xinfo.display, xinfo.window, xinfo.gc, &points[0],			points.size(), CoordModeOrigin ); 
		}		Polyline(int x, int y) { add_point(x,y);}	
		void add_point(int x, int y) {			XPoint p; // XPoint is a built in struct 
			p.x=x; p.y=y; 
			points.push_back(p);		}		
		private:			vector < XPoint > points; // XPoint is a built in struct		};

--
Displaying the Display Lost

	list<Displayable*> dList; // list of Displayables	
	dList.push_front(new Paddle(...)); 
	dList.push_front(new Ball(...)); 	
	dList.push_front(new Background(...));	/* Function to repaint a display list */	void repaint( list<Displayable*> dList, XInfo& xinfo) {		list<Displayable*>::const_iterator begin = dList.begin(); 		list<Displayable*>::const_iterator end = dList.end();		XClearWindow( xinfo.display, xinfo.window );		while( begin != end ) { 
			Displayable* d = *begin; 
			d->paint(xinfo); 
			begin++;		}		XFlush( xinfo.display ); 
	}

--
Summary

- Basic X architecture (client, server, network)
- Windows: opening,disposing
- Drawing
	- Models (pixel, stroke, region)
	- Graphics contexts
	- Painter’s Algorithm
	- Display lists


##Getting Started with Git##
*Introduction to version control, Benefits of using Git, Basic commands, Workflow*

--
添加 1.2



##Java Class Libraries##
*Packages, Class framework, Building GUIs with Swing*

--
Java Platfrom (JDK)

- The Java Platform includes extensive cross- platform libraries to do everything from threading to database queries to user-interfaces.

--
Java Class Library

- Classes are grouped into packages (i.e. namespaces) to avoid name collisions.
- To assign your source code to a package, use the package keyword at the top of source files.
- Typically, package = subdirectory
	- e.g. “graphics” package is in subdirectory of the same name
	- alt. it can be included in a JAR file.
	- For simplicity, samples and assignments won’t normally use packages.- Use the import keyword to import a package
	- This is how you include bundled Java libraries.

--
Common Classes/Packages

- java.awt
	- Classes(Examples): Color, Graphics, Graphics2D, event.
	- Description: Contains all of the classes for creating user interfaces and for painting graphics and images.
- javax.swing
	- Classes(Examples): JFrame, JButton, JList, JToolbar
	- Description: Provides a set of "lightweight" (all- Java language) components that works the same on all platforms.
- java.io
	- Classes(Examples): File, FileReader, FileWriter, InputStream
	- Description: Provides for system input and output through data streams, serialization and the file system.
- java.lang
	- Classes(Examples): Boolean, Integer, String, System, Thread, Math
	- Description: Provides classes that are fundamental to the design of the Java programming language.
- java.util
	- Classes(Examples): ArrayList, HashMap, Observable
	- Description: Contains the collections framework, legacy collection classes, event model,...

--
Java Class Hierarchy

- Implicit class hierarchy	- All classes in Java are derived from the Object class in java.lang defines and implements common class behavior		- e.g. clone(), toString(), finalize() methods
	- Classes you write inherit this basic behavior.


***
##Building Swing Interfaces##
*Widgets overview, creating a window, using Swing components, using listeners, PaintDemo*

--
Widget

- Widget is a generic name for parts of an interface that have their own behavior: buttons, progress bars, sliders, drop-down menus, spinners, file dialog boxes. They are also called “components”, or “controls”.
- Widgetsaretypicallypackagedintolibraries (toolkits) for reuse. Operating systems often bundle their own toolkits.
- Widgets have two main responsibilities:
	- Widgets are responsible for drawing themselves, based on their current state.
	- Widgets receive and interpret their own events (from BWS/WM or some container).

--
Java UI Toolkits

Java has four user-interface libraries, each with different types of widgets (and strengths/tradeoffs)..

Toolkit (Release): Description

- AWT (1995): “Heavyweight” with platform-specific widgets. AWT applications were limited to common-functionality that existed on all platforms.
- Swing (1997): “Lightweight”, full widget implementation. Commonly used and deployed cross- platform.
- Standard Window Toolkit / SWT (~2000): ”Heavyweight” hybrid model: native, and tied to specific platforms. Used in Eclipse.
- Java FX (~2010): Intended for rich desktop + mobile apps. Still in development.

--
Java AWT, Swing, SWT

- Java’s cross-platform goal required a decision:
	- AWT, which supports the “lowest common denominator” of widgets across all supported platforms.
	- Swing, which deployed a set of standard widgets (and behavior and look-and-feel) across all platforms.
	- SWT, which provided close-to-native implementations, but are very platform specific (and difficult to port to new platforms).- There are pluses and minuses to each approach.- We use Swing exclusively for assignments.

--
Swing Component Hierarchy

- java.awt.Window is the base for all containers.- javax.swing.Jcomponent is the root for all widgets.

###*add pic here*###

--
How to use Swing

1. Create a top-level application window, using a Swing container (JFrame or JDialog).2. Add Swing components to this window.
	- Typically, you create a smaller container (like a JPanel) and add components to the panel.
	- This makes dynamic layouts easier (more on that later in the course!)3. Add listeners for all events, like keyboard (press), mouse (down, up, move)4. Make components update and paint themselves based on input/events.

--
Simple Swing Example




##2D Graphics##
*Shapes Models, Drawing, Selection*

--
Graphics Models vs. Images

- Computer Graphics: the creation, storage, and manipulation of images and their models- Model: a mathematical representation of an image containing the important properties of an object (location, size, orientation, color, texture, etc.) in data structures- Rendering: Using the properties of the model to create an image to display on the screen- Image: the rendered model

--
Example Shape models

- A “shape model” is a type of model that includes all of the data that we need to draw a particular shape.
	- An array of points: {P1, P2, ..., Pn}
	- Can be open, closed, filled...
	- Includes any other data that we need to draw- Allows for reuse of shape models in code
- Java supports primitive shapes (Lines, Ellipses, Rectangles) with tools for building others (CubicCurves, Paths, drawPolygon, drawPolyline, fillPolygon)

--
Typical Interaction

- What do we need to support interaction with user interfaces?
	- Ability to draw shapes/widgets on the screen		- at specified position, size, orientation
		- perhaps draw many copies, each different from the others	- Ability to test when a shape/widget is “selected” or “clicked”		- could be a filled or outlined polygon or a polyline		- selections that “just miss” the shape should “snap” to shape
- Programmer tasks:

*Now: what we did in X, in Java*

*Next: 2D transformations*
	- create a model of the shape
	- draw it
	- choose a “selection” paradigm
	- implement shape hit tests and/or inside tests (with snapping)
	- respond to events

--
SimpleDraw: Drawing in Java

5-7

--
Selection Paradigms

- Clickselection	- different for filled and outlined shapes- Rubberband rectangle- Lasso (Ch 14 of Olsen text, for an example)

--
Closest Shape to Mouse Test

- Check distance from every line segment of every shape to mouse position (can be optimized ...)
- Check distance from mouse to line segment using vector projection
- ClosestPointDemo.java

--
Note on ClosestPointDemo Example

- The ClosestPointDemo example will NOT RUN ON YOUR MACHINE USING THE STANDARD INSTALL!!!!
- Need vecmath.jar	- Download it online, place it in your directory, and use the – cp command line switch to include it	- Or try installing java3d – ymmv.	- javac -cp vecmath.jar ClosestPointDemo.java	- java –cp .;vecmath.jar ClosestPointDemo	- NOTE THE “.;” IN THE SECOND COMMAND- The makefile included the samples will build and run itproperly

##Affine Transformations##
*Transforming shapes, scene graphs, interact trees, interacting with transformed shapes*

--
Affine Transformation

- The interactor tree describes the hierarchy of widgets in an interface	- Widget location is always specified in terms of parent’s coordinate system (i.e. relative or local coordinates).		- We need to do some math before painting
		- Performing hit test requires taking parent location into account (i.e. determining which components a given location corresponds to, relative to its parent)- In this lecture, we’ll show how to use affine transformations to:1. Manipulate and transform widgets (shape models).2. Tell widgets how to draw themselves on-screen, relative to their parent.3. Determine if a mouse-click intersects one of these widgets in the interactor tree.

--
Linear Algebra: Review of Terms

(s) Scalar: a single value (usually real number)(v) Vector: directed line segment (represents direction and magnitude)(P) Point: a fixed location in space (represents a position)- Legal operations:	- vector+vector:v1+v2=v3
	- vector multiplied by a scalar: v1 x s1=v4 • point minus point = P1-P2 = v5
	- point+vector:P2+v5=P1
	- 2 ways to“multiply” vector by vector
		- dot (inner) product: v1 o v2 = s2
		- cross (outer) product: v1 x v2 = v6


	 









